https://www.nowcoder.com/discuss/256030?type=0&order=0&pos=120&page=1

#### TCP流量控制与拥塞控制 

参考：[1](https://www.cnblogs.com/myworld7/p/8385190.html)

[2](https://andrewpqc.github.io/2018/07/21/tcp-flow-control-and-congestion-control/)

追求高速的传输速率是当今网络的永恒主题，但有时候我们也需要对**发送方进行控制**以提供流量控制服务和拥塞控制服务。这一片文章就介绍一下TCP的流量控制服务和拥塞控制服务。

# 流量控制

## 流量控制的定义

前面讲过，一条TCP连接每一侧主机都为该连接设置了接收缓存。当该TCP连接收到了正确的、按序的字节后，他就将数据放入接收缓存。相关联的应用进程会从该缓存中读取数据。但不必是数据一到达就立即读取。事实上，接收方也许正忙于其他任务，甚至要过很长时间后才读取该数据。**如果某个应用进程读取比较缓慢，但是发送方发送的太多、太快，发送的数据就会很容易地使该连接的接收缓存溢出。**

TCP为它的应用程序提供了**流量控制服务(flow-control service)**以消除发送方使接收方缓存溢出的可能性。流量控制因此是一个**速度匹配服务**，即发送方的发送速率与接收方应用程序的读取速率相匹配。

## 流量控制的实现

TCP通过让**发送方**维护一个称为**接收窗口(receive window)的变量(TCP报文段首部的接收窗口字段)来提供流量控制**。通俗的讲，接收窗口用于给发送方一个指示－－该接收方还有多少可用的缓存空间。因为TCP是**全双工**通信，在连接两端的发送方都各自维护了一个接收窗口。

![img](C:\Users\n\OneDrive - std.uestc.edu.cn\秋招\assets\slide_23.jpg)

如上图所示`RcvBuffer`是接收缓存的总大小，`buffered data`是当前已经缓存了的数据，而`free buffer space`是当前剩余的缓存空间大小,`rwnd`的值就是`free buffer space`。主机B通过把当前的`rwnd`值放入到它发送给主机A的报文段首部的接收窗口字段中，通知主机A它在该连接的缓存中还有多少可用空间。
而**主机A则将自己发往主机B的序号空间中未确认的数据量控制在rwnd值的范围内**,这样就可以避免主机A使主机B的接收缓存溢出。

# 拥塞控制

## 为什么需要拥塞控制?

我们在前面讲到过，在TCP协议中，分组丢失一般是当网络变得拥塞时由路由器缓存溢出引起的。

因此**分组重传**是作为网络拥塞的征兆来对待，但是却**无法处理导致网络拥塞的原因**，因为有太多的源想以过高的速率发送数据。一旦网络发生拥塞，分组所经历的时延会变大，分组丢失的可能性会变大，发送端需要重传的分组会变多，这只会导致网络越来越拥塞，形成恶性循环。因此，为了处理网络拥塞，需要一些机制以在面临网络拥塞时遏制发送方。

- 端到端拥塞控制
  在端到端的拥塞控制中，网路层没有为运输层提供显示支持。即使网络中存在拥塞，端系统也必须通过对网络行为的观察(如分组的丢失与时延)来推理判断之。
- 网络辅助的拥塞控制
  在网络辅助的拥塞控制中，网络层构件(即路由器)向发送方提供关于网络中拥塞状态的显示反馈信息。拥塞信息从网络反馈到发送发通常有两种方式:直接反馈信息可以由网络路由器发给发送方，这种方式的通知通常采用一种阻塞分组的形式；第二种方法是路由器标记或更新从发送方流向接收方的分组中的某个字段来指示拥塞的产生，一旦收到一个标记的分组后，接收方就会向发送方发送该网络拥塞指示。

![img](assets/a0HYBRB.png)

## TCP拥塞控制

TCP是通过端到端的方法来解决拥塞控制的，因为IP层不会向端系统提供有关网络拥塞的反馈信息。TCP报文段的丢失被认为是网络拥塞的一个迹象，TCP会相应的减小其窗口长度。这里我们需要明确的几个问题是:
1.TCP发送方如何限制它向其连接发送流量的速率?
2.TCP发送方如何感知从它到目的地之间的路径上存在拥塞呢?
3.当感知到了拥塞时，采用何种算法来改变其发送速率呢?

首先我们来考虑TCP发送方怎样限制它向网络发送流量的速率。与流量控制一样，在发送方的TCP拥塞控制机制中跟踪了一个额外的变量，即**拥塞窗口**(congestion window)。拥塞窗口表示为cwnd,通过这个拥塞窗口，我们就能够对发送方向其连接发送数据的速率进行限制。具体的措施是:**让一个发送方中未确认的数据量不会超过cwnd和rwnd的最小值**，即:

> LastByteSend - LastByteAcked <= min{cwnd,rwnd}

LastByteSend,LastByteAcked分别是最后一个发送的字节的序号和最后一个被确认的字节的序号。

如前所述TCP发送方通过**捕获到丢包时间的产生**感知从它到目的地之间的路径上存在拥塞。

在拥塞情况发生时，我们可以通过减小cwnd的值来减小发送方发送数据的速率。那么如果没有拥塞发生呢?如果没有拥塞，我们应该增加cwnd的值来增大发送方发送数据的速率。发送方发送速率过大会导致网络拥塞，甚至拥塞崩溃；而如果发送方过于谨慎，发送太慢则不能充分利用带宽。因此根据网络情况合理设置cwnd的值非常重要

在概述了TCP拥塞控制之后，现在我们来考虑一下广受赞誉的TCP拥塞控制算法。该算法包括三部分:**慢启动，拥塞避免，快速恢复**。

### 慢启动

当一条TCP连接开始，cwnd值通常初始置为一个MSS较小值。这使得初始发送速率为MSS/RTT。在慢启动(slow-start)状态，cwnd的值以1个MSS开始并且每当传输的报文段首次被确认就增加一个MSS。

![img](assets/4vCVSNC.png)

何时结束慢启动阶段的指数增长呢？
①如果存在一个由超时指示的丢包事件，TCP发送方将cwnd设置为1并重新开始慢启动过程。它还将第二个状态变量的值ssthresh（慢启动阈值）设置为cwnd/2，即当检测到拥塞时将ssthresh置为拥塞窗口值的一半。
②当检测到拥塞时ssthresh设为cwnd的一半，当到达或超过ssthresh的值时，结束慢启动并且TCP转移到拥塞避免模式。
③如果检测到3个冗余ACK，这时TCP执行一种快速重传并进入快速恢复状态。

### 拥塞避免

每个RTT只将cwnd的值增加一个MSS(Maximum Segment Size 最大报文段长度)：对于TCP发送方无论何时到达一个新的确认，就将cwnd增加一个MSS(MSS/cwnd)字节。例如，如果MSS是1460字节，并且cwnd是14 600字节，则在一个RTT内发送10个报文段。每个到达ACK增加1/10MSS的拥塞窗口长度，因此在收到对所有10个报文段的确认后，拥塞窗口的值将增加了一个MSS。当出现超时时，TCP的拥塞避免与慢启动阶段一样。当出现丢包时，网络继续从发送方向接收方交付报文段，当接收到3个冗余ACK时，将ssthresh的值置为cwnd的一半，同时将cwnd的值减半加上3个MSS。

### 快速恢复

1）对收到的每个用冗余ACK，cwnd值增加一个MSS。
2）当对丢失报文段的一个ACK到达时，TCP在降低cwnd进入拥塞避免状态。
3）如果出现超时事件，执行如同慢启动和拥塞避免中相同的动作后，迁移到慢启动状态.

### http 和https区别，https怎样实现安全？

**1.理解http与https的概念**

**（1）HTTP**：超文本传输协议 (HTTP-Hypertext transfer protocol)，是互联网上应用最为广泛的一种网络协议，是一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

​     **HTTP的会出现的问题**：http协议属于**明文传输协议**，交互过程以及数据传输都**没有进行加密**，通信双方也没有进行任何认证，通信过程非常**容易遭遇劫持、监听、篡改**，严重情况下，会造成恶意的流量劫持等问题，甚至造成个人隐私泄露（比如银行卡卡号和密码泄露）等严重的安全问题。

**（2）HTTPS**：**是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL**。现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。

​    **HTTPS**协议可以分为两种：一是通过建立一个信息安全通道，来保证数据传输的安全；二是通过确认网站的真实性。

**HTTPS在HTTP的基础上加入了SSL/TLS协议，依靠SSL证书来验证服务器的身份，并为客户端和服务器端之间建立“SSL加密通道”，确保用户数据在传输过程中处于加密状态，同时防止服务器被钓鱼网站假冒，而HTTP协议无法加密数据，所有通信数据都在网络中明文“裸奔”。通过网络的一些技术手段，就可还原HTTP报文内容。**

![img](assets/2579937-d3b0ff7525d618d0.webp)

**2.简要了解HTTP和HTTPS的区别？**

> （1）HTTP 是超文本传输协议，属于明文传输协议，HTTPS 则是具有安全性的基于ssl加密的传输协议
>
> （2）HTTP 和 HTTPS 使用的是连接方式不同，而且用的端口也不一样,前者是80,后者是443。
>
> （3）HTTP 是简单的无状态的连接。HTTPS 协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议 要比 HTTP 协议安全
>
> （4）HTTPS 内容经过对称加密，每个连接生成一个唯一的加密密钥（**对称秘钥**:对称密钥加密又叫专用密钥加密，即发送和接收数据的双方必使用相同的密钥对明文进行加密和解密运算。）
>
> （5）HTTPS 内容传输经过完整性校验

**3.HTTPS是如何保证数据的安全？**

（1）客户端向服务器端发起SSL连接请求；（在此过程中依然存在数据被中间方盗取的可能，下面将会说明如何保证此过程的安全）

（2） 服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥

（3）客户端用公钥对双方通信的对称秘钥进行加密，并发送给服务器端

（4）服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密，在此过程中，中间方无法对其解密（即使是客户端也无法解密，因为只有服务器端拥有唯一的私钥），这样保证了对称秘钥在收发过程中的安全，此时，服务器端和客户端拥有了一套完全相同的对称秘钥。

（5）进行数据传输，服务器和客户端双方用公有的相同的对称秘钥对数据进行加密解密，可以保证在数据收发过程中的安全，即是第三方获得数据包，也无法对其进行加密，解密和篡改。

#### 覆盖索引？最左前缀原则？

索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。

> 如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引。

**判断标准**

使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为**using index**,MySQL查询优化器在执行查询前会决定是否有索引覆盖查询

**注意**

1、覆盖索引也并不适用于任意的索引类型，索引必须存储列的值

2、Hash 和full-text索引不存储值，因此MySQL只能使用B-TREE

3、并且不同的存储引擎实现覆盖索引都是不同的

4、并不是所有的存储引擎都支持它们

5、**如果要使用覆盖索引，一定要注意SELECT 列表值取出需要的列**，不可以是SELECT *，因为如果将所有字段一起做索引会导致索引文件过大，查询性能下降，不能为了利用覆盖索引而这么做

覆盖索引是一种非常强大的工具，能大大提高查询性能，只需要读取索引而不用读取数据。有以下一些优点

> 1、索引项通常比记录要小，所以MySQL访问更少的数据
> 2、索引都按值的大小顺序存储，相对于随机访问记录，需要更少的I/O
> 3、大多数据引擎能更好的缓存索引，比如MyISAM只缓存索引
> 4、覆盖索引对于InnoDB表尤其有用，因为InnoDB使用聚集索引组织数据，如果二级索引中包含查询所需的数据，就不再需要在聚集索引中查找了

##### 最左前缀原则

假设数据 表 T (a,b,c) rowid 为物理位置

```
rowid a b c
(1) 1 1 1
(2) 2 1 13
(3) 2 2 14
(4) 1 3 3
(5) 2 3 12
(6) 1 2 5
(7) 2 3 9
(8) 1 2 2
(9) 1 3 6
(10) 2 2 11
(11) 2 2 8
(12) 1 1 7
(13) 2 3 15
(14) 1 1 4
(15) 2 1 10
```

当你创建一个索引 create index xxx on t(a,b)，则索引文件逻辑上等同于如下

```
a b rowid
1 1 1
1 1 12
1 1 14
1 2 6
1 2 8
1 3 4
1 3 9
2 1 2
2 1 15
2 2 3
2 2 10
2 2 11
2 3 5
2 3 7
2 3 13
```

当 select * from T where a = 1 and b = 3 的时候， 数据库系统可以直接从索引文件中直接二分法找到 A = 1 的记录，然后再 B = 3 的记录
但如果你 where b = 3 则需要遍历这个索引表的全部

mysql 建立多列索引（联合索引）有最左前缀的原则，**即最左优先**，如：

如果有一个 2 列的索引 (col1, col2)，则已经对 (col1)、(col1, col2) 上建立了索引；
如果有一个 3 列索引 (col1, col2, col3)，则已经对 (col1)、(col1, col2)、(col1, col2, col3) 上建立了索引；

##### 原理

- b+ 树的数据项是复合的数据结构，比如 (name,age,sex) 的时候，b+ 树是按照**从左到右的顺序**来建立搜索树的，比如当 (张三,20,F) 这样的数据来检索的时候，b+ 树会优先比较 name 来确定下一步的所搜方向，如果 name 相同再依次比较 age 和 sex，最后得到检索的数据；但当 (20,F) 这样的没有 name 的数据来的时候，b+ 树就不知道第一步该查哪个节点，因为建立搜索树的时候 name 就是第一个比较因子，必须要先根据 name 来搜索才能知道下一步去哪里查询
- 比如当 (张三, F) 这样的数据来检索时，b+ 树可以用 name 来指定搜索方向，但下一个字段 age 的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是 F 的数据了， 这个是非常重要的性质，即索引的最左匹配特性。（这种情况无法用到联合索引）

# MySQL事务隔离级别

首先创建一个表account。创建表的过程略过（由于InnoDB存储引擎支持事务，所以将表的存储引擎设置为InnoDB）。表的结构如下：

![img](assets/2607748-8179e4fc53b73fc0.webp)

然后往表中插入两条数据，插入后结果如下：

![img](assets/2607748-b9bbca7325852c48.webp)

为了说明问题，我们打开两个控制台分别进行登录来模拟两个用户（暂且成为用户A和用户B吧），并设置当前MySQL会话的事务隔离级别。

#### 一. read uncommitted（读取未提交数据）

具体用户A的操作如下：

```mysql
set session transaction isolation level read uncommitted；
start transaction;
select * from account;
```

结果如下：

![img](assets/2607748-b9bbca7325852c48-1568362069553.webp)

用户B的操作如下：

```bash
set session transaction isolation level read uncommitted；
start transaction;
update account set account=account+200 where id = 1;
```

随后我们在A用户中查询数据，结果如下：

![img](assets/2607748-a0fbe25be92e6621.webp)

结论一：

我们将事务隔离级别设置为read uncommitted，即便是事务**没有commit**，但是我们仍然**能读到未提交的数据**，这是所有隔离级别中最低的一种。

**那么这么做有什么问题吗？**
那就是我们在一个事务中可以随随便便读取到其他事务未提交的数据，这还是比较麻烦的，我们叫脏读。我不知道这个名字是怎么起的，为了增强大家的印象，可以这么想，这个事务好轻浮啊，饥渴到连别人没提交的东西都等不及，真脏，呸！

实际上我们的数据改变了吗？

答案是否定的，因为只有事务commit后才会更新到数据库。

#### 二. read committed（可以读取其他事务提交的数据）---大多数数据库默认的隔离级别

同样的办法，我们将用户B所在的会话当前事务隔离级别设置为read commited。

在用户A所在的会话中我们执行下面操作：

```bash
update account set account=account-200 where id=1;
```

![img](assets/2607748-9234df9cc22f3a5b.webp)

我们将id=1的用户account减200。然后查询，发现id=1的用户account变为800。

在B用户所在的会话中查询：

```csharp
select * from account；
```

![img](assets/2607748-9d518364ab9b4cc0.webp)

我们会发现数据并没有变，还是1000。

接着在会话A中我们将事务提交：

```undefined
commit;
```

在会话B中查询结果如下：

![img](assets/2607748-d9436e13f7be17df.webp)

结论二：
当我们将当前会话的**隔离级别设置为read committed的**时候，当前会话只能读取到**其他事务提交**的数据，未提交的数据读不到。
那么这么做有什么问题吗？
那就是我们在会话B同一个事务中，读取到两次不同的结果。这就造成了**不可重复读**，就是**两次读取的结果不同**。这种现象叫不可重复读。

#### 三. repeatable read（可重读）---MySQL默认的隔离级别

现在有个**需求**，就是老板说在**同一个事务中查询结果必须保持一致**，如果你是数据库，你会怎么做？数据库是这么做的。

在会话B中我们当前事务隔离级别为repeatable read。具体操作如下：

```bash
set session transaction isolation level repeatable read;
start transaction;
```

接着在会话B中查询数据：

![img](assets/2607748-29f109af023757b4.webp)

我们在A用户所在会话中为表account添加一条数据：

```csharp
insert into account(id,account) value(3,1000);
commit;
```

然后我们查询看数据插入是否成功：

![img](assets/2607748-62d0f8d3524f5e2f.webp)

回到B用户所在的会话，我们查询结果：

![img](assets/2607748-bad6b8fcf218f2f5.webp)

用户B在他所在的会话中想插入一条新数据id=3，value=1000。来我们操作下：

![img](assets/2607748-da79749a21d4568f.webp)

**什么？竟然插不进去，说我数据重复？**
用户B当然不服啊，因为查询到数据只有两条啊，为什么插入id=3说我数据重复了呢？

我再看一遍，莫非我眼花了？

![img](assets/2607748-bad6b8fcf218f2f5-1568362969700.webp)

> 试想一下，在实际中用户A和用户B肯定是相互隔离的，彼此不知道操作什么。用户B碰到这种现象，肯定会炸毛的啊，明明不存在的数据，插入却说主键id=3数据重复了。

结论三：
当我们将当前会话的隔离级别设置为repeatable read的时候，**当前会话可以重复读，就是每次读取的结果集都相同，而不管其他事务有没有提交。**
有什么问题吗？
管他呢，老板的要求满足了。要一个事务中读取的数据一致（可重复读）。我只能这么做啊，打肿脸装胖子。数据已经发生改变，但是我还是要保持一致。但是，出现了用户B面对的问题，这种现象叫**幻读**（记得当时就在这个地方纠结好久，到底什么是幻读啊）。

##### 四. serializable（串行化）

同样，我们将用户B所在的会话的事务隔离级别设置为serializable并开启事务。

```bash
set session transaction isolation level serializable;
start transaction;
```

在**用户B**所在的会话中我们执行下面操作：

```csharp
select * from account;
```

结果如下：

![img](assets/2607748-ae20fd30cc93b41d.webp)

那我们这个时候在用户A所在的会话中写数据呢？

![img](assets/2607748-91a0ce7dba1971e9.webp)

我们发现用户A所在的会话陷入等待，如果超时（这个时间可以进行配置），会出现Lock wait time out提示：

![img](assets/2607748-e3f08966650c0f8e.webp)

如果在等待期间我们用户B所在的会话事务提交，那么用户A所在的事务的写操作将提示操作成功。

> 结论四：
> 当我们将当前会话的隔离级别设置为serializable的时候，其他会话对该表的写操作将被挂起。可以看到，这是隔离级别中最严格的，但是这样做势必对性能造成影响。所以在实际的选用上，我们要根据当前具体的情况选用合适的。

##### 事务是什么？4大原则？

> 事务就是用户定义的一系列执行SQL语句的操作, 这些操作要么完全地执行，要么完全地都不执行， 它是一个不可分割的工作执行单元。

四大特性：ACID

> Atomicity 原子性，**Consistency 一致性**，Isolation隔离性， Duriability 持久性

**一致性**：  数据库总是从一个一致性的状态转换到另一个一致性的状态。（在前面的例子中，一致性确保了，即
使在转账过程中系统崩溃，支票账户中也不会损失200美元，因为事务最终没有提交，所以事务中所做
的修改也不会保存到数据库中。）

​	**说明:事务能够保证数据的完整性和一致性，让用户的操作更加安全。**

#### ArrayList、Vector（向量类）和LinkedList的区别

> ArrayList、Vector和LinkedList类均在java.util包下，均为可伸缩数组，即可以动态改变长度的数组

ArrayList和Vector都是基于存储元素的Object[] array来实现的，它们会在内存中开辟一块连续的空间

来存储，因为数据存储是连续的，所以它们支持用下标来访问元素，索引数据的速度比较快

1）ArrayList和Vector都有一个**初始化的容量大小**，当里面存储的元素超过初始的大小时就需要**动态地**扩充

它们的存储空间，Vector默认扩充为原来的两倍（每次扩充空间的大小可以设置），ArrayList默认

扩充为原来的1.5倍（没有提供方法来设置空间扩充的方法）。

2）ArrayList和Vector最大的区别就是**synchronization**的使用，没有一个ArrayList的方法是同步的，而

**Vector的绝大多数方法（如add,insert,remove,set,equals,hashcode）都是直接或间接同步的**，所以Vector

是线程安全的，ArrayList不是线程安全的。正是由于Vector提供了线程安全的机制，其性能上也要稍逊于ArrayList；

3）LinkedList是采用双向列表来实现的，对数据的索引需要从列表头开始遍历，因此用于随机访问则效率比较低，

但是插入元素时不需要对数据进行移动，因此插入效率较高。同时，**LinkedList是非线程安全的容器**

**对容器的选择：**

> 1. 当对数据的主要操作是索引或只在集合的末端增加、删除元素时，使用ArrayList或Vector效率比较高，
>
> 2. 当对数据的操作主要为指定位置或删除操作时，使用LikedList效率比较高；
> 3. 当在多线程中使用容器时，选用Vector较为安全

#### hashmap  hashtable区别？

###### Hashtable简介

>   Hashtable同样是基于哈希表实现的，同样每个元素是一个key-value对，其内部也是通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。
>
> Hashtable也是JDK1.0引入的类，**是线程安全的**，能用于多线程环境中
>
>  Hashtable同样实现了Serializable接口，它支持序列化，实现了Cloneable接口，能被克隆。

区别：

1、继承的父类不同


      Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类。但二者都实现了Map接口。

 2、线程安全性不同

```
  javadoc中关于hashmap的一段描述如下：此实现不是同步的。如果多个线程同时访问一个哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。
```


    Hashtable 中的方法是Synchronize的，而HashMap中的方法在缺省情况下是非Synchronize的。在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步，但使用HashMap时就必须要自己增加同步处理。
    
    （结构上的修改是指添加或删除一个或多个映射关系的任何操作；仅改变与实例已经包含的键关联的值不是结构上的修改。）这一般通过对自然封装该映射的对象进行同步操作来完成。如果不存在这样的对象，则应该使用 Collections.synchronizedMap 方法来“包装”该映射。最好在创建时完成这一操作，以防止对映射进行意外的非同步访问，如下所示：
    
      Map m = Collections.synchronizedMap(new HashMap(...));
    
      Hashtable 线程安全很好理解，因为它每个方法中都加入了Synchronize。这里我们分析一下HashMap为什么是线程不安全的：

3、**是否提供contains方法**

```
 HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey，因为contains方法容易让人引起误解。
 Hashtable则保留了contains，containsValue和containsKey三个方法，其中contains和containsValue功能相同。
```

4、key和value是否允许null值

```
 Hashtable中，key和value都不允许出现null值。但是如果在Hashtable中有类似put(null,null)的操作，编译同样可以通过，因为key和value都是Object类型，但运行时会抛出NullPointerException异常，这是JDK的规范规定的。
HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，可能是 HashMap中没有该键，也可能使该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。
```

5、两个遍历方式的内部实现上不同

```
 Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。
```

 6、hash值不同

```
哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。
hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值。
Hashtable计算hash值，直接用key的hashCode()，而HashMap重新计算了key的hash值，
Hashtable在求hash值对应的位置索引时，用取模运算，而HashMap在求位置索引时，则用与运算，且这里一般先用hash&0x7FFFFFFF后，再对length取模，&0x7FFFFFFF的目的是为了将负的hash值转化为正值，因为hash值有可能为负数，而&0x7FFFFFFF后，只有符号外改变，而后面的位都不变。
```

7、内部实现使用的数组初始化和扩容方式不同

```
 HashTable在不指定容量的情况下的默认容量为11，而HashMap为16，Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂。
 Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。
 Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1
```

##### hashmap底层原理？

1）用于存储Key-Value 键值对的散列通；

2）put 方法  以及

index=hash(key)

3）get方法

index=hash(key)  得到在table中的位置，同一个位置有可能匹配到多个Entry，这时候就需要顺着对应链表的头节点，一个一个向下来查找。

**判断key是不是唯一**，如果key唯一，则直接返回，如果不唯一，则**使用equals进行值的判断，最后返回数据**。

4）HashMap的初始长度

初始长度为16，且每次自动扩容或者手动初始化的时候必须是2的幂。

从Key映射到HashMap数组的对应位置，会用到一个Hash函数：
`index = Hash（“apple”）`

如何实现一个尽量均匀分布的Hash函数呢？我们通过利用Key的HashCode值来做某种运算。
`index = HashCode（Key） & （Length - 1）`

下面我们以值为“book”的Key来演示整个过程：

1. 计算book的hashcode，结果为十进制的3029737，二进制的`101110001110101110 1001`。
2. 假定HashMap长度是默认的16，计算Length-1的结果为十进制的15，二进制的1111。
3. 把以上两个结果做与运算，`101110001110101110 1001 & 1111 = 1001`，十进制是9，所以 index=9。
   可以说，Hash算法最终得到的index结果，完全取决于Key的Hashcode值的最后几位。这里的位运算其实是一种快速取模算法。

**HashMap 的size为什么必须是2的幂?**。

> 这是因为2的幂用二进制表示时所有位都为1，例如16-1=15 的二进制就是1111B。我们说了Hash算法是为了让hash 的分布变得均匀。
>
> 其实我们可以把1111看成四个通道，表示跟1111 做&**运算后分布是均匀的**。
>
> 假如默认长度取10，二进制表示为1010，这样就相当于有两个通道是关闭的，所以计算出来的索引重复的几率比较大。

#### 反射机制？在哪里用到？	

参考：[Java：一步步带你深入了解神秘的Java反射机制](https://blog.csdn.net/carson_ho/article/details/80921333)

**反射定义**

- 定义：`Java`语言中 一种 **动态（运行时）**访问、检测 & 修改它本身的能力
- 作用：动态（运行时）获取**类的完整结构信息 & 调用对象的方法**

> 1. 类的结构信息包括：变量、方法等
> 2. 正常情况下，`Java`类在编译前，就已经被加载到`JVM`中；而反射机制使得程序运行时还可以动态地去操作类的变量、方法等信息

###### 应用场景

- 动态获取 **类文件结构信息（如变量、方法等） & 调用对象的方法**
- 常用的需求场景有：动态代理、工厂模式优化、`Java JDBC`数据库操作等

##### 红黑树？怎么插入？

##### 为什么用spring？

##### redis的恢复策略你用哪个？