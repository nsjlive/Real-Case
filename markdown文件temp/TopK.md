1B（byte，字节）= 8 bit

1KB（Kilobyte，[千字节](https://baike.baidu.com/item/千字节)）=[10](https://baike.baidu.com/item/10)24B= 2^10 B

1[MB](https://baike.baidu.com/item/MB)（Megabyte，[兆字节](https://baike.baidu.com/item/兆字节)，百万字节，简称“兆”）=1024KB= 2^20 B；

1[GB](https://baike.baidu.com/item/GB)（Gigabyte，[吉字节](https://baike.baidu.com/item/吉字节)，十亿字节，又称“千兆”）=1024MB= 2^30 B；

### **问题描述：**

这是在网上找到的一道百度的面试题：

搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。



附：**外部排序算法**

> 插入排序、选择排序、归并排序等等，这些算法都属于内部排序算法，即**排序的整个过程只是在内存中完成**。而当待排序的文件比内存的可使用容量还大时，文件无法一次性放到内存中进行排序，需要借助于**外部存储器（例如硬盘、U盘、光盘）**，这时就需要用到本章介绍的**外部排序**算法来解决。

> **外部排序算法**由两个阶段构成：
> **按照内存大小**，将大文件分成若干长度为 l 的子文件（l 应小于内存的可使用容量），然后将各个子文件依次读入内存，使用适当的内部排序算法对其进行排序（排好序的子文件统称为“归并段”或者“顺段”），将排好序的归并段重新写入外存，为下一个子文件排序腾出内存空间；对得到的顺段进行合并，直至得到整个有序的文件为止。例如，有一个含有 10000 个记录的文件，但是内存的可使用容量仅为 1000 个记录，毫无疑问需要使用外部排序算法，具体分为两步：将整个文件其等**分**为 10 个临时文件（每个文件中含有 1000 个记录），然后将这 10 个文件依次进入内存，采取适当的内存排序算法对其中的记录进行排序，将得到的有序文件（初始归并段）移至外存。对得到的 10 个初始**归并**段进行如图 1 的两两归并，直至得到一个完整的有序文件。

> 注意：此例中采用了将文件进行等分的操作，还有不等分的算法，后面章节会介绍。

如图 1 所示有 10 个初始归并段到一个有序文件，共进行了 4 次归并，每次都由 m 个归并段得到 ⌈m/2⌉ 个归并段，这种归并方式被称为 2-路平衡归并。

> 注意：在实际归并的过程中，由于内存容量的限制不能满足同时将 2 个归并段全部完整的读入内存进行归并，只能不断地取 2 个归并段中的每一小部分进行归并，通过不断地读数据和向外存写数据，直至 2 个归并段完成归并变为 1 个大的有序文件。

对于外部排序算法来说，影响整体排序效率的因素主要取决于**读写外存的次数**，即访问外存的次数越多，算法花费的时间就越多，效率就越低。

> 计算机中处理数据的为中央处理器（CPU），如若**需要访问外存中的数据**，只能通过将数据**从外存导入内存，然后从内存中获取**。同时由于内存读写速度快，外存读写速度慢的差异，更加影响了外部排序的效率。

> 对于同一个文件来说，对其进行外部排序时访问外存的次数同归并的次数成正比，即归并操作的次数越多，访问外存的次数就越多。图 1 中使用的是 2-路平衡归并的方式，举一反三，还可以使用 3-路归并、4-路归并甚至是 10-路归并的方式，图 2 为 5-路归并的方式：

> 对比 图 1 和图 2可以看出，对于 k-路平衡归并中 k 值得选择，增加 k 可以减少归并的次数，从而减少外存读写的次数，最终达到提高算法效率的目的。除此之外，一般情况下对于具有 m 个初始归并段进行 k-路平衡归并时，归并的次数为：s=⌊logk⁡m ⌋（其中 s 表示归并次数）。

> 从公式上可以判断出，想要达到减少归并次数从而提高算法效率的目的，可以从两个角度实现：
>
> 1. 增加 k-路平衡归并中的 k 值；
> 2. 尽量减少初始归并段的数量 m，即增加每个归并段的容量；

> 其增加 k 值的想法引申出了一种外部排序算法：多路平衡归并算法；增加数量 m 的想法引申出了另一种外部排序算法：置换-选择排序算法。两种外部排序算法会在后序章节中详细介绍。

#### **问题解析：**

【分析】：要统计最热门查询，首先就是要统计每个Query出现的次数，然后根据统计结果，找出Top 10。所以我们可以基于这个思路分两步来设计该算法。下面分别给出这两步的算法：

第一步：**Query统计**

#### **算法一：直接排序法**

首先我们能想到的算法就是排序了，首先对这个日志里面的所有Query都进行排序，然后再遍历排好序的Query，统计每个Query出现的次数了。但是题目中有明确要求，那就是内存不能超过1G，一千万条记录，每条记录是225Byte，很显然要占据2.55G内存，这个条件就不满足要求了。

> 1000w条记录，一般认为1000近似位1024=2^10处理，
>
> 故1000w=1000 * 1000 * 10 ~2^10 *2^10 *10=10  *  2^20  
>
> 每条记录是225Byte,故1000W条数据是2250*2^20Byte=2.25 * 2^30Byte =2.25GB

让我们回忆一下数据结构课程上的内容，当数据量比较大而且内存无法装下的时候，我们可以采用**外排序**的方法来进行排序，这里笔者采用归并排序，是因为归并排序有一个比较好的时间复杂度O(NlgN)。

排完序之后我们再对已经有序的Query文件进行遍历，**统计每个Query出现的次数**，再次写入文件中。

综合分析一下，排序的时间复杂度是O(NlgN)，而遍历的时间复杂度是O(N)，因此该算法的总体时间复杂度就是O(NlgN)。

#### **算法二：Hash Table法**

在上个方法中，我们采用了排序的办法来统计每个Query出现的次数，时间复杂度是NlgN，那么能不能有更好的方法来存储，而时间复杂度更低呢？

题目中说明了，虽然有一千万个Query，但是由于重复度比较高，因此事实上只有300万的Query，每个Query255Byte，因此我们可以考虑把他们都放进内存中去，而现在只是需要一个合适的数据结构，在这里，Hash Table绝对是我们优先的选择，因为**Hash Table的查询速度**非常的**快**，几乎是O(1)的时间复杂度。

那么，我们的算法就有了：维护一个Key为Query字串，Value为该Query出现次数的HashTable，每次读取一个Query，如果该字串不在Table中，那么加入该字串，并且将Value值设为1；如果该字串在Table中，那么将该字串的计数加一即可。最终我们在O(N)的时间复杂度内完成了对该海量数据的处理。

本方法相比算法一：在**时间复杂度**上提高了一个数量级，但不仅仅是**时间复杂度上的优化**，该方法只需要**IO数据文件一次**，而算法一的IO次数较多的，因此该算法比算法一在工程上有更好的可操作性。

### **第二步：找出Top 10**

#### **算法一：排序**

我想对于排序算法大家都已经不陌生了，这里不在赘述，我们要注意的是排序算法的时间复杂度是NlgN，在本题目中，三百万条记录，用1G内存是可以存下的。

#### **算法二：部分排序**

题目要求是求出Top 10，因此我们没有必要对所有的Query都进行排序，我们只需要维护一个10个大小的数组，初始化放入10Query，按照每个Query的统计次数由**大到小排序**，然后遍历这300万条记录，每读一条记录就和数组最后一个Query对比，如果小于这个Query，那么继续遍历，否则，将数组中最后一条数据淘汰，加入当前的Query。最后当所有的数据都遍历完毕之后，那么这个数组中的10个Query便是我们要找的Top10了。

不难分析出，这样的算法的时间复杂度是N*K， 其中K是指top多少。

#### **算法三：堆**

在算法二中，我们已经将时间复杂度由NlogN优化到NK，不得不说这是一个比较大的改进了，可是有没有更好的办法呢？

分析一下，在算法二中，**每次比较完成之后，需要的操作复杂度都是K**，**因为要把元素插入到一个线性表之中，而且采用的是顺序比较**。

这里我们注意一下，该数组是有序的，一次我们每次查找的时候**可以采用二分的方法查找**，这样操作的复杂度就降到了logK，可是，随之而来的问题就是数据移动，因为移动数据次数增多了。不过，这个算法还是比算法二有了改进。

基于以上的分析，我们想想，有没有一种**既能快速查找，又能快速移动元素**的数据结构呢？回答是肯定的，那就是**堆**。借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此到这里，我们的算法可以改进为这样，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比。。。

##### **结语：**

至此，我们的算法就完全结束了，经过步骤一和步骤二的最优结合，我们最终的时间复杂度是O（N） + O（N’）logK。如果各位有什么好的算法，欢迎跟帖讨论。

