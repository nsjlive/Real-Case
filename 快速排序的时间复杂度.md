**在最优情况**

Partition每次都划分得很均匀,如果排序n个关键字，其递归树的深度就为
$$
\log_2(2n+1),节点个数为n
$$
例如2个节点，深度为2.

第一次Partiation应该是需要对整个数组扫描一遍，做n次比较。

获得的枢轴将数组一分为二，那么各自还需要T（n/2）的时间（注意是最好情况，所以平分两半）
$$ {  }
分成2块：T（n）≤2T（n/2） +n，T（1）=0,其中n=(\log_22)\times n
$$
不断地划分下去，我们就有了下面的不等式推断
$$
分成4块：T（n）≤2（2T（n/4）+n/2） +n=4T（n/4）+2n,其中2n=(\log_24)\times n
$$

$$
分成8块：T（n）≤4（2T（n/8）+n/4） +2n=8T（n/8）+3n  
……
$$

$$
分成n块：T（n）≤nT（1）+（\log_2n）×n= O(n\log_2n)
$$

也就是说，在最优的情况下，快速排序算法的时间复杂度为O(nlogn)。

**最坏的情况**，

待排序的序列为正序或者逆序，每次划分只得到一个比上一次划分少一个记录的子序列，注意另一个为空。如果递归树画出来，它就是**一棵斜树**。

此时需要执行n‐1次递归调用，且第i次划分需要经过n‐i次关键字的比较才能找到第i个记录，也就是枢轴的位置，因此比较次数为

![img](http://images.51cto.com/files/uploadimg/20110826/222653304.jpg)

最终其时间复杂度为O(n^2)。

**平均的情况**

设枢轴的关键字应该在第k的位置（1≤k≤n），那么：
$$
T(n)=\frac{1}{n}\sum_{k=1}^{n}({T(k-1)+T(n-k))+n}=\frac{2}{n}\sum_{k=1}^{n}{T(k)+n}
$$
**空间复杂度**，

主要是递归造成的栈空间的使用，最好情况，递归树的深度为
$$
log_2n
$$
其空间复杂度也就为 O(logn)，

**最坏情况**，

需要进行n‐1递归调用，其空间复杂度为O(n)，

**平均情况，**

空间复杂度也为O(logn)。