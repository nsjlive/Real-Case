**Java的八大基本类型**

​	四种整数类型（byte、int、long 、short）、两种浮点数类型（ float、double） 、布尔类型boolean、字符类型 char 。

​	类型转换：char-->    自动转换：byte-->short-->int-->long-->float-->double     强制转换：①会损失精度，产生误差，小数点以后的数字全部舍弃。②容易超过取值范围。

​	记忆：8位：Byte（字节型）   16位：short（短整型）、char（字符型）    32位：int（整型）、float（单精度型/浮点型）   64位：long（长整型）、double（双精度型）    最后一个：boolean(布尔类型。

**Java除了基本类型以外还有哪些类能表示数字**

Java 中除了有基本类型还有包装类型，通过装箱拆箱机制，同样可以表示数字。

不仅仅如此，还有大数的类可以表示数字：两个高精度大整数BigInteger 和高精度浮点数BigDecimal。

除了这个大数类型外，还有原子类型AtomicBoolean,AtomicInteger,AtomicLong,AtomicReference，AtomicIntegerFieldUpdater,AtomicLongFieldUpdater, AtomicReferenceFieldUpdater。

**介绍JVM堆和栈，有什么用，A a = new A()；各放在哪个位置**

堆：FIFO队列优先，先进先出。jvm只有一个堆区被所有线程所共享！堆存放在二级缓存中，调用对象的速度相对慢一些，生命周期由虚拟机的垃圾回收机制定。
 栈：FILO先进后出，**暂存数据**的地方。每个线程都包含一个栈区！栈存放在一级缓存中，存取速度较快，“栈是限定仅在表头进行插入和删除操作的线性表”。
 方法区：用来存放方法和static变量。

Java虚拟机中堆栈功能简单总结：

> 1、对象主要存放在堆内存中；方法和属性主要存放在栈内存中。 
>
> 2、栈是运行时单位，用来解决程序运行时的问题，堆是存储单位，解决数据存储的问题。
>
> 3、堆伴随着JVM的启动而创建。

优缺点

1、堆的优点-可以动态的分配内存大小，生命周期不确定。缺点-速度略慢
2、栈的优点-速度快，缺点-存在栈中的数据大小和生命周期必须是明确的，缺少灵活性。

###### 栈区:

每个线程包含一个栈区，栈中只保存方法中（不包括对象的成员变量）的**基础数据类型**和自定义对象的**引用**(不是对象)，**对象都存放在堆区**中，每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。

###### 堆区:

存储的全部是**对象实例**，每个对象都包含一个与之对应的class的信息(class信息存放在方法区)。jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身，几乎所有的**对象实例和数组**都在堆中分配。

**方法区:**

又叫静态区，跟堆一样，被所有的线程共享。它用于存储**已经被虚拟机加载**的类信息、常量、静态变量、即时编译器编译后的代码等数据。

方法区（非堆）：是**各个线程共享**的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

java堆：是虚拟机中所管理的内存中区域最大的一块，是被所有**线程共享**的一块内存区域，**在虚拟机启动时创建**。此内存区域的**唯一目的就是存放对象实例**，几乎所有的对象实例都在这里分配内存。java堆是**垃圾收集器**管理的主要区域。

java虚拟机栈：**线程私有**的，它的生命周期与线程相同。每个方法被执行的时候都会同时创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。

代码执行的时候是执行一个方法，执行完，返回方法的上一个代码块继续往下执行后面的内容。这样的话是不是就是一个栈结构了？

先进后出。方法一边执行，一边往栈里面存数据，等执行完了就取出数据（取出的是返回值，是最后一个存进去的 栈结构是后进先出），

然后执行外面的代码。这么说你可能不明白，我给你举个例子。

```java
int sub(int a, int b){
	return a+b;
}
```

int c=sub(2,3);   //注意执行这条语句的时候是不是执行了一个方法？

//那么语句执行的时候是要从左往右执行的对吧，但是事实的逻辑却是先算出来sub（2，3）这个方法的返回值（5）赋值给 c ，那么这个怎么实现，肯定是一个栈的数据结构，编译的时候先把”int c = “入栈，然后再把 sub（2，3），入栈，执行的时候，从栈里面取，取的第一个肯定是sub（2，3）吧？于是就计算出等于5，继续取，取出了int c =，然后就和5对接上了，就把值赋给c了。这只是一个小例子。

**HashMap扩容过程，初始容量，和HashTable的区别**

 [HashMap源码](<https://mp.weixin.qq.com/s?__biz=MzI3ODg2OTY1OQ==&mid=2247483957&idx=1&sn=e865001c7284ac5b00e67507c1b9410c&chksm=eb5121c1dc26a8d76cda63ba0dcbc1ffa259bd0b68759d6f887bd8b2a88b07eddc79a980b55a&scene=21#wechat_redirect> "Title")

HashMap的初始容量为16，HashMap的容量指的是存储元素的数组大小，即桶的数量

HashMap/HashTable内部用Entry数组实现哈希表，而对于映射到同一个哈希桶（数组的同一个位置）的键值对，使用Entry链表来存储(解决hash冲突)。

Hashtable和hashmap的区别总结
1、 hashmap中key和value均可以为null，但是hashtable中key和value均不能为null。

2、 hashmap采用的是数组(桶位)+链表+红黑树结构实现（jdk1.8之后），而hashtable中采用的是数组(桶位)+链表实现。

3、 hashmap中出现hash冲突时，如果链表节点数小于8时是将新元素加入到链表的末尾，而hashtable中出现hash冲突时采用的是将新元素加入到链表的开头。

4、 hashmap中数组容量的大小要求是2的n次方，如果初始化时不符合要求会进行调整，必须为2的n次方，而hashtable中数组容量的大小可以为任意正整数。

5、 hashmap中的寻址方法采用的是**位运算按位与**,而hashtable中寻址方式采用的是求余数。

6、 hashmap不是线程安全的，而hashtable是线程安全的，hashtable中的get和put方法均采用了synchronized关键字进行了方法同步。

**构造线程的方法**

线程的创建一共有四种方式：

- 继承于`Thread`类，重写run（）方法；
- 实现`Runable`接口，实现里面的run（）方法；
- 使用 `FutureTask` 实现有返回结果的线程
- 使用`ExecutorService`、`Executors` 线程池。

在详细了解这四种方法之前，先来理解一下为什么线程要这样创建：形象点来说，Thread是一个工人，run（）方法里面的便是他的任务栏，这个任务栏默认是空的。当你想要这个线程做点什么时，你可以重写Thread里面的run方法，重写这个工人的任务栏；也可以通过runable、callable接口，从外部赋予这个工人任务。还可以将任务交给一堆工人，谁有空就谁就承担这个任务（线程池）。

参考：[创建线程的四种方式](<https://blog.csdn.net/sihai12345/article/details/80256322>)

 **mysql优化**

mysql优化：[Mysql优化](https://links.jianshu.com/go?to=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI3ODg2OTY1OQ%3D%3D%26mid%3D2247485099%26idx%3D1%26sn%3Daf95eb7ca0d72480a6071b870a0bd674%26chksm%3Deb51255fdc26ac4997ff9173459bf8d5078a1d53fe277cc4458e859f97d8177c88c5f926919f%26scene%3D21%23wechat_redirect)

**spring IOC的作用，有哪些注解，有什么用**

老问题了，分享一篇简单易懂的文章
[https://www.cnblogs.com/xdp-gacl/p/4249939.html](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Fxdp-gacl%2Fp%2F4249939.html)

