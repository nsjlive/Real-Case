## JVM内存分配机制、内存模型、垃圾回收

# **1. jvm结构**

**JVM的内部体系结构分为三部分　**

**（1）类装载器（ClassLoader）子系统　　　　作用: 用来装载.class文件　**

**（2）执行引擎　　　　作用:执行字节码，或者执行本地方法　**

**（3）运行时数据区　　　　方法区，堆，java栈，PC寄存器，本地方法栈**

**JVM类加载简介：**

![img](https://images2015.cnblogs.com/blog/724399/201610/724399-20161018225024763-1807607336.png)

 **JVM将整个类加载过程划分为了三个步骤：**

（1）装载
　　**装载过程负责找到二进制字节码并加载至JVM中。**JVM通过类名、类所在的包名通过ClassLoader来完成类的加载，同样，也采用以上三个元素来标识一个被加载了的类：==**类名+包名+ClassLoader实例ID**==。
（2）链接
　　**链接过程负责对二进制字节码的格式进行校验**、初始化装载类中的静态变量以及解析类中调用的接口、类。在完成了校验后，JVM初始化类中的静态变量，并将其值赋为默认值。最后一步为**对类中的所有属性、方法进行验证，以确保其需要调用的属性、方法存在，以及具备应的权限**（例如public、private域权限等），会造成NoSuchMethodError、NoSuchFieldError等错误信息。
（3）初始化
　　**初始化过程即为执行类中的静态初始化代码、构造器代码以及静态属性的初始化。**在四种情况下初始化过程会被触发执行：调用了new；反射调用了类中的方法；子类调用了初始化；JVM启动过程中指定的初始化类。

**类装载器和执行引擎详细介绍点击这里，以下主要介绍运行时数据区。**

## **JVM方法区结构（内存模型）**

程序计数器、本地方法栈、方法区、Java栈、Java堆及其他隐含寄存器。

![img](https://img-blog.csdnimg.cn/20181227111012141.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MTEwMTMy,size_16,color_FFFFFF,t_70)

## 1.1 程序计数器

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

由于Java 虚拟机的多线程是通过**线程轮流切换并分配处理器执行时间的方式**来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“**线程私有**”的内存。

如果线程正在执行的是一个Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie 方法，这个计数器值则为空（Undefined）。

## 1.2 虚拟机栈（java栈）

**线程私有，它的生命周期与线程相同。**虚拟机栈描述的是Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。

关于栈帧详解，参考[jvm运行时栈帧结构详解](http://blog.csdn.net/zq602316498/article/details/38926607)

动画是由一帧一帧图片连续切换结果的结果而产生的，其实虚拟机的运行和动画也类似，每个在虚拟机中运行的程序也是由许多的帧的切换产生的结果，只是这些帧里面存放的是方法的局部变量，操作数栈，动态链接，方法返回地址和一些额外的附加信息组成。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

对于执行引擎来说，活动线程中，只有栈顶的栈帧是有效的，称为**当前栈帧**，这个栈帧所关联的方法称为**当前方法**。**执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作**。

## 1.3 本地方法栈

本地方法栈（Native MethodStacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是==虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务==，而==本地方法栈则是为虚拟机使用到的Native 方法服务==。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如**Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一**。

与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。

## 1.4 方法区

方法区在一个jvm实例的内部，**类型信息**被存储在一个称为方法区的内存逻辑区中。类型信息是由类加载器在类加载时从类文件中提取出来的。类(静态)变量也存储在方法区中。

简单说方法区用来存储类型的元数据信息，一个.class文件是类被java虚拟机使用之前的表现形式，一旦这个类要被使用，java虚拟机就会对其进行装载、连接（验证、准备、解析）和初始化。而装载（后的结果就是由.class文件转变为方法区中的一段特定的数据结构。这个数据结构会存储如下信息：

**1.4.1 类型信息**

​      这个类型的全限定名

​      这个类型的直接超类的全限定名

​      这个类型是类类型还是接口类型

​      这个类型的访问修饰符

​      任何直接超接口的全限定名的有序列表

**1.4.2 字段信息**

​      字段名

​      字段类型

​      字段的修饰符

**1.4.3 方法信息**

​      方法名

​      方法返回类型

​      方法参数的数量和类型（按照顺序）

​      方法的修饰符

**1.4.4 其他信息**

​      除了常量以外的所有类（静态）变量

​      一个指向ClassLoader的指针

​      一个指向Class对象的指针

​      常量池（常量数据以及对其他类型的符号引用）

**方法区主要有以下几个特点**：

1、==方法区是线程安全的==。由于所有的线程都共享方法区，所以，方法区里的数据访问必须被设计成线程安全的。例如，假如同时有两个线程都企图访问方法区中的同一个类，而这个类还没有被装入JVM，那么只允许一个线程去装载它，而其它线程必须等待

2、方法区的大小不必是固定的，JVM可根据应用需要动态调整。同时，方法区也不一定是连续的，方法区可以在一个堆(甚至是JVM自己的堆)中自由分配。

3、方法区也可被垃圾收集，当某个类不在被使用(不可触及)时，JVM将卸载这个类，进行垃圾收集

可以通过**-XX:PermSize** 和 **-XX:MaxPermSize** 参数限制方法区的大小（实际为限制非堆内存的大小，其中包含方法区）。关于内存设置详见[这里](https://blog.csdn.net/m0_38110132/article/details/84287114)

## 1.5 堆

堆是Java 虚拟机所管理的==内存中最大的一块==。Java 堆是被所有==线程共享==的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例**，几乎所有的对象实例都在这里分配内存。但是随着JIT 编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。

**堆是垃圾收集器管理的主要区域**，因此很多时候也被称做“**GC 堆**”。

### **1.5.1 堆内存与栈内存需要说明**

基础数据类型直接在栈空间分配，方法的形式参数，直接在栈空间分配，==当方法调用完成后从栈空间回收==。引用数据类型，需要用new来创建，既在栈空间分配一个地址空间，又在堆空间分配对象的类变量 。方法的引用参数，在栈空间分配一个地址空间，并指向堆空间的对象区，当方法调用完成后从栈空间回收。

==局部变量new==出来时，在栈空间和堆空间中分配空间，当局部变量生命周期结束后，栈空间立刻被回收，堆空间区域等待GC回收。方法调用时传入的literal参数，先在栈空间分配，在方法调用完成后从栈空间收回。*字符串常量、static在DATA区域分配，this在堆空间分配。数组既在栈空间分配数组名称，又在堆空间分配数组实际的大小。*

## 总结

![1556458476817](C:\Users\n\AppData\Roaming\Typora\typora-user-images\1556458476817.png)

# 2.GC机制

[**搞定JVM垃圾回收就是这么简单**]([https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/%E6%90%9E%E5%AE%9AJVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B9%88%E7%AE%80%E5%8D%95.md](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/搞定JVM垃圾回收就是这么简单.md))

垃圾收集器一般必须完成两件事：检测出垃圾；回收垃圾。怎么检测出垃圾？一般有以下几种方法：

## 2.1 引用计数法

给一个对象添加引用计数器，每当有个地方引用它，计数器就加1；引用失效就减1。

好了，==问题==来了，如果我有**两个对象A和B，互相引用**，除此之外，没有其他任何对象引用它们，实际上这两个对象已经无法访问，即是我们说的垃圾对象。但是互相引用，计数不为0，导致无法回收，所以还有另一种方法：

## 2.2 可达性分析算法

以==根集对象==为起始点进行搜索，如果有==对象不可达的话，即是垃圾对象==。**这里的根集一般包括java栈中引用的对象、方法区常量池中引用的对象、本地方法中引用的对象等。**

总之，JVM在做垃圾回收的时候，会检查堆中的所有对象是否会被这些根集对象引用，不能够被引用的对象就会被垃圾收集器回收。

## 2.3 一般回收算法也有如下几种

### 2.3.1 按照基本回收策略分

### **（1）标记-清除（Mark-sweep）**

算法和名字一样，分为两个阶段：标记和清除。标记所有需要回收的对象，然后统一回收。这是==最基础的算法==，后续的收集算法都是基于这个算法扩展的。

不足：效率低；标记清除之后会产生大量碎片。效果图如下：

### **（2）复制（Copying）**

此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。此算法==每次只处理正在使用中的对象==，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。效果图如下：

### **（3）标记-整理（Mark-Compact）**

根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是==让所有存活的对象向一端移动==，然后直接清理掉端边界以外的内存。

此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。效果图如下：

### 2.3.2 按分区对待的方式分

**（1）增量收集（Incremental Collecting）:**实时垃圾回收算法，即：在应用进行的同时进行垃圾回收。不知道什么原因JDK5.0中的收集器没有使用这种算法的。

**（2）分代收集（Generational Collecting）:**基于对对象生命周期分析后得出的垃圾回收算法。把对象分为==年青代、年老代、持久代==，对不同生命周期的对象使用不同的算法（上述方式中的一个）进行回收。现在的垃圾回收器（从J2SE1.2开始）都是使用此算法的。

### 2.3.3 按系统线程分（回收器类型）

**（1）串行收集:**串行收集==使用单线程处理所有垃圾回收工作==，因为无需多线程交互，实现容易，而且效率比较高。但是，其局限性也比较明显，即**无法使用多处理器的优势，所以此收集适合单处理器机器**。当然，此收集器也可以用在小数据量（100M左右）情况下的多处理器机器上。默认使用串行收集器。

**（2）并行收集:**并行收集使用多线程处理垃圾回收工作，因而速度快，效率高。而且理论上CPU数目越多，越能体现出并行收集器的优势。**适合对吞吐量优先（科学技术，后台应用），无过多交互的应用**。吞吐量=业务处理时间/（业务处理时间+垃圾回收时间）。

**-XX:+UseParallelGC** 设置年轻代为并行收集器，

**-XX:ParallelGCThreads=20**设置并行收集器线程数,一般设置为与CPU数相同。

**-XX:+UseParallelOldGC** 设置年老代为并行收集器。**-XX:+UseAdaptiveSizePolicy**设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。

**（3）并发收集:**相对于串行收集和并行收集而言，前面两个在进行垃圾回收工作时，需要暂停整个运行环境，而只有垃圾回收程序在运行，因此，系统在垃圾回收时会有明显的暂停，而且暂停时间会因为堆越大而越长。**并发收集器不会暂停应用，适合响应时间优先的应用。**保证系统的响应时间，减少垃圾收集时的停顿时间。==适用于应用服务器、电信领域==等。

**-XX:+UseConcMarkSweepGC**：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。
**-XX:+UseParNewGC**:设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。

## **2.4 常见配置汇总**

1. 堆设置
   - **-Xms**:初始堆大小
   - **-Xmx**:最大堆大小
   - **-XX:NewSize=n**:设置年轻代大小
   - **-XX:NewRatio=n:**设置年轻代和年老代的比值。默认为2.，表示年轻代与年老代比值为1：2，年轻代占整个年轻代年老代和的1/3
   - **-XX:SurvivorRatio=n**:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。默认为8，表示Eden：Survivor=8：2，一个Survivor区占整个年轻代的1/10
   - **-XX:MaxPermSize=n**:设置持久代大小
2. 收集器设置
   - **-XX:+UseSerialGC**:设置串行收集器
   - **-XX:+UseParallelGC**:设置并行收集器
   - **-XX:+UseParalledlOldGC**:设置并行年老代收集器
   - **-XX:+UseConcMarkSweepGC**:设置并发收集器
3. 垃圾回收统计信息
   - **-XX:+PrintGC**
   - **-XX:+PrintGCDetails**
   - **-XX:+PrintGCTimeStamps**
   - **-Xloggc:filename**
4. 并行收集器设置
   - **-XX:ParallelGCThreads=n**:设置并行收集器收集时使用的CPU数。并行收集线程数。
   - **-XX:MaxGCPauseMillis=n**:设置并行收集最大暂停时间
   - **-XX:GCTimeRatio=n**:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)
5. 并发收集器设置
   - **-XX:+CMSIncrementalMode**:设置为增量模式。适用于单CPU情况。
   - **-XX:ParallelGCThreads=n**:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。

## **2.5 JVM调优总结**

1. 年轻代大小选择

   - **响应时间优先的应用**：**尽可能设大，直到接近系统的最低响应时间限制**（根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象。
   - **吞吐量优先的应用**：尽可能的设置大，可能到达Gbit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用。

2. 年老代大小选择

   - 1)响应时间优先的应用

     ：年老代使用并发收集器，所以其==大小需要小心设置==，一般要考虑

     并发会话率和会话持续时间等一些参数。如果堆设置小了，可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：

     - 并发垃圾收集信息
     - 持久代并发收集次数
     - 传统GC信息
     - 花在年轻代和年老代回收上的时间比例

     减少年轻代和年老代花费的时间，一般会提高应用的效率

   - 2)**吞吐量优先的应用**：一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以==尽可能回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象==。

   ## **2.6 GC收集器辅助信息**

   JVM提供了大量命令行参数，打印信息，供调试使用。主要有以下一些：

   - -XX:+PrintGC

     输出形式

     ：[GC 118250K->113543K(130112K), 0.0094143 secs]

     ​                **[Full GC 121376K->10414K(130112K), 0.0650971 secs]**

   - -XX:+PrintGCDetails

     输出形式

     ：[GC [DefNew: 8614K->781K(9088K), 0.0123035 secs] 118250K->113543K(130112K), 0.0124633 secs]

     ​                **[GC [DefNew: 8614K->8614K(9088K), 0.0000665 secs][Tenured: 112761K->10414K(121024K), 0.0433488 secs] 121376K->10414K(130112K), 0.0436268 secs]**

   - **-XX:+PrintGCTimeStamps** -XX:+PrintGC：PrintGCTimeStamps可与上面两个混合使用
     输出形式：**11.851: [GC 98328K->93620K(130112K), 0.0082960 secs]**

   - **-XX:+PrintGCApplicationConcurrentTime:**打印每次垃圾回收前，程序未中断的执行时间。可与上面混合使用
     输出形式：**Application time: 0.5291524 seconds**

   - **-XX:+PrintGCApplicationStoppedTime**：打印垃圾回收期间程序暂停的时间。可与上面混合使用
     输出形式：**Total time for which application threads were stopped: 0.0468229 seconds**

   - **-XX:PrintHeapAtGC**:打印GC前后的详细堆栈信息

   - **-Xloggc:filename**:与上面几个配合使用，把相关日志信息记录到文件以便分析。

   注：参考自 http://pengjiaheng.iteye.com/blog/520228 <https://blog.csdn.net/liang0000zai/article/details/50040227> ）

    

   **关于以下GC分代回收部分，主要参考自：http://blog.csdn.net/suifeng3051/article/details/48292193 感谢原作者。**

   ## 2.7 虚拟机的GC过程

   ### 2.7.1 为什么要分代回收

   在一开始的时候，JVM的GC就是采用标记-清除-压缩方式进行的，这么做并不是很高效，因为当对象分配的越来越多时，对象列表也越来也大，扫描和移动越来越耗时，造成了内存回收越来越慢。然而，经过根据对java应用的分析，发现==大部分对象的存活时间都非常短，只有少部分数据存活周期是比较长的==，请看下面对java对象内存存活时间的统计：

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20150908161120944)

从图表中可以看出，==大部分对象存活时间是非常短的，随着时间的推移，被分配的对象越来越少==。

### 2.7.2 虚拟机的GC过程

经过上面介绍，我们已经知道了JVM为何要分代回收，下面我们就详细看一下整个回收过程。

1. 在初始阶段，新创建的对象被分配到Eden区，survivor的两块空间都为空。 

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20150908161234962)

2. 当Eden区满了的时候，minor garbage 被触发 

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20150908161305686)

3. ==经过扫描与标记，存活的对象被复制到S0，不存活的对象被回收== 

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20150908161339708)

4. 在下一次的Minor GC中，Eden区的情况和上面一致，==没有引用的对象被回收，存活的对象被复制到survivor区==。然而在survivor区，S0的所有的数据都被复制到S1，需要注意的是，在上次minor GC过程中移动到S0中的两个对象在复制到S1后其年龄要加1。此时Eden区S0区被清空，所有存活的数据都复制到了S1区，并且S1区存在着年龄不一样的对象，过程如下图所示： 

   ![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20150908161353425)

5. 再下一次MinorGC则重复这个过程，这一次survivor的两个区对换，存活的对象被复制到S0，存活的对象年龄加1，Eden区和另一个survivor区被清空。

   ![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20150908161406353)

6. 下面演示一下Promotion过程，再经过几次Minor GC之后，当存活对象的年龄达到一个阈值之后（可通过参数配置，**默认是8**），就会被从年轻代Promotion到老年代。 ![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20150908161419362)

7. 随着MinorGC一次又一次的进行，不断会有新的对象被promote到老年代。 ![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20150908161435368)
8. 上面基本上覆盖了整个年轻代所有的回收过程。最终，MajorGC将会在老年代发生，老年代的空间将会被清除和压缩。 ![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20150908161446256)

从上面的过程可以看出，==Eden区是连续的空间，且Survivor总有一个为空==。经过一次GC和复制，一个Survivor中保存着当前还活着的对象，而Eden区和另一个Survivor区的内容都不再需要了，可以直接清空，到下一次GC时，两个Survivor的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的**“停止-复制（Stop-and-copy）”****清理法**（将Eden区和一个Survivor中仍然存活的对象拷贝到另一个Survivor中），这不代表着停止复制清理法很高效，其实，它也只在这种情况下（基于大部分对象存活周期很短的事实）高效，如果在老年代采用停止复制，则是非常不合适的。

老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，==老年代用的算法是标记-压缩算法==，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。在发生Minor GC时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次Full GC，否则，就查看是否设置了`-XX:+HandlePromotionFailure`（允许担保失败），如果允许，则只会进行MinorGC，此时可以容忍内存分配失败；如果不允许，则仍然进行Full GC（这代表着如果设置`-XX:+Handle PromotionFailure`，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。

关于方法区即永久代的回收，永久代的回收有两种：常量池中的常量，无用的类信息，常量的回收很简单，没有引用了就可以被回收。对于无用的类进行回收，必须保证3点：

```
1. 类的所有实例都已经被回收
2. 加载类的ClassLoader已经被回收
3. 类对象的Class对象没有被引用（即没有通过反射引用该类的地方）
```

永久代是用于存放静态文件，如Java类、方法等。 
持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class。

==永久代的回收并不是必须的==，可以通过参数来设置是否对类进行回收。