1. ### DNS解析

2. ### TCP连接

3. ### 发送HTTP请求

4. ### 服务器处理请求并返回HTTP报文

5. ### 浏览器解析渲染页面

6. ### 连接结束

   

## DNS解析

​	域名系统**（[英文](https://baike.baidu.com/item/英文)：**D**omain **N**ame **S**ystem，[缩写](https://baike.baidu.com/item/缩写)：**DNS**）是[互联网](https://baike.baidu.com/item/互联网)的一项服务。它作为将[域名](https://baike.baidu.com/item/域名)和[IP地址](https://baike.baidu.com/item/IP地址)相互[映射](https://baike.baidu.com/item/映射)的一个[分布式数据库](https://baike.baidu.com/item/分布式数据库)，能够使人更方便地访问[互联网](https://baike.baidu.com/item/互联网)。

​	 DNS解析的过程就是**寻找哪台机器上有你需要资源的过程**。当你在浏览器中输入一个地址时，例如www.baidu.com，其实不是百度网站真正意义上的地址。互联网上每一台计算机的**唯一标识是它的IP地址**，但是IP地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度的网址。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是**一个网址到IP地址的转换**，这个过程就是DNS解析。它实际上充当了一个翻译的角色，实现了网址到IP地址的转换。网址到IP地址转换的过程是如何进行的?

![img](https://image-static.segmentfault.com/161/828/1618288278-57f00bf9444dd)

​	上述图片是查找www.google.com的IP地址过程。首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。

​	从上述过程中，可以看出网址的解析是一个从右向左的过程: com -> google.com -> www.google.com。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是www.google.com**.**  ，并不是我多打了一个.，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为: . -> com. -> google.com. -> www.google.com.。



## DNS优化

​	了解了DNS的过程，可以为我们带来哪些？上文中请求到google的IP地址时，经历了8个步骤，这个过程中存在多个请求(同时存在UDP和TCP请求，为什么有两种请求方式，请自行查找)。如果每次都经过这么多步骤，是否太耗时间？**如何减少该过程的步骤呢？那就是DNS缓存**。

##### DNS缓存

DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。

- 在你的chrome浏览器中输入:chrome://dns/，你可以看到chrome浏览器的DNS缓存。

- 系统缓存主要存在/etc/hosts(Linux系统)中:

  ![DNSç³»ç»ç¼å­](https://segmentfault.com/img/bVDM5c?w=956&h=366)



##### DNS负载均衡

* 不知道大家有没有思考过一个问题: **DNS返回的IP地址是否每次都一样？**如果每次都一样是否说明你请求的资源都位于同一台机器上面，那么这台机器需要多高的性能和储存才能满足亿万请求呢？其实真实的互联网世界背后存在成千上百台服务器，大型的网站甚至更多。但是在用户的眼中，它需要的只是处理他的请求，哪台机器处理请求并不重要。**DNS可以返回一个合适的机器的IP给用户**，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是**DNS负载均衡**，又叫做DNS重定向。大家耳熟能详的CDN(Content Delivery Network)就是利用**DNS的重定向技术**，DNS服务器会返回一个**跟用户最接近的点的IP地址给用户**，CDN节点的服务器负责响应用户的请求，提供所需的内容。在这里打个免费的广告，我平时使用的比较多的是七牛云的CDN(免费)储存图片，作为我个人博客的图床使用。

### TCP连接

​	HTTP协议是使用TCP作为其传输层协议的，当TCP出现瓶颈时，HTTP也会受到影响。

## SSL

Secure Socket Layer，为[Netscape](https://baike.baidu.com/item/Netscape)所研发，用以保障在Internet上数据传输之安全，利用[数据加密](https://baike.baidu.com/item/数据加密)(Encryption)技术，可确保数据在网络上之传输过程中不会被截取及窃听。

#### HTTPS协议

​	我不知道把HTTPS放在这个部分是否合适，但是放在这里好像又说的过去。***HTTP报文是包裹在TCP报文中发送*的，*服务器端收到TCP报文时会解包提取出HTTP报文***。但是这个过程中存在一定的风险，==HTTP报文是明文，如果中间被截取的话会存在一些信息泄露的风险==。那么在进入TCP报文之前对HTTP做一次加密就可以解决这个问题了。HTTPS协议的本质就是HTTP + SSL(or TLS)。在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密。从网络的层级结构看它位于HTTP协议与TCP协议之间。

![HTTPS](https://segmentfault.com/img/bVp65j)

```ruby

```

#### HTTPS过程

HTTPS在传输数据之前需要客户端与服务器进行一个握手(==TLS/SSL握手==)，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL使用了非对称加密，对称加密以及hash等。具体过程请参考经典的阮一峰先生的博客[TLS/SSL握手过程](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)。
HTTPS相比于HTTP，虽然提供了安全保证，但是势必会带来一些**时间上的损耗**，如握手和加密等过程，是否使用HTTPS需要根据具体情况在安全和性能方面做出权衡。

### HTTP请求

其实这部分又可以称为前端工程师眼中的HTTP，它==主要发生在客户端==。发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。HTTP请求报文是由三部分组成: **请求行**, **请求报头**和**请求正文**。

#### 请求行

格式如下:
`Method Request-URL HTTP-Version CRLF`

```
eg: GET index.html HTTP/1.1
```

常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD。

TODO：

- GET和POST有什么区别？

> GET和POST是什么?==是HTTP协议中的两种发送请求的方法==。
>  HTTP是什么?HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。
>  HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，**GET/POST都是TCP链接**。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。

那所谓的区别呢？稍微总结了下（以下参考了在今日头条看到的一篇文章）。
 运输快递需要车辆，而TCP就像车辆，但如果车辆全部按自己的想法走，交通就会瘫痪，所以交通规则HTTP诞生了。HTTP规定了运输方式：get、post、head、options、put等。当执行get请求时，车上贴get标签，货物放在上层运输。如果是post请求，车上贴post标签，货物放在下层运输。当然，get方式也可以把货物放在下层，但是这样是算get还是post呢？所以，==*HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本*==。

而关于传递的参数大小问题，是这样的。
 过大的数据量会增加运输成本，超出的部分，概不处理，那还不如乖按照规定走。所以，浏览器通常都会限制url长度在2K个字节，而(大多数)服务器最多处理64K大小的url。==如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略==，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。

GET和POST还有一个重大区别，简单的说：
 GET产生一个TCP数据包;POST产生两个TCP数据包。
 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);
 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)

好吧，至于这个答案。面试有待验证。
 至于面试，老老实实回答还是有必要的，暂时为以下答案：

1. **get在浏览器回退时是无害的，而post会再次请求**
2. **get产生的url地址可以被收藏，而post不会**
3. get请求会被浏览器主动缓存，而post不会，除非手动设置
4. get请求只能进行url编码，而post支持多种编码方式
5. **get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留**
6. **get 请求在url中传送的参数有长度限制，而post没有**
7. 对参数的数据类型，get只接受ascll字符，而post没有限制
8. get比post更安全，因为参数直接暴露在url上，所以不能用来传递敏感信息
9. **get参数通过url传递，poet放在request body中**
    （记不住全部的，重点回答出1，2，5，6，9这几点即可）

参考：https://www.jianshu.com/p/fcdc0f86633a

#### 请求报头

请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。
PS: **客户端不一定特指浏览器**，有时候也可使用Linux下的CURL命令以及HTTP客户端测试工具等。
常见的请求报头有: *Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent等*。

![HTTPåæ](https://segmentfault.com/img/bVC1BZ?w=1919&h=822)

- [x] ​	上图是使用Chrome开发者工具截取的对百度的HTTP请求以及响应报文，从图中可以看出，请求报头中使用了Accept, Accept-Encoding, Accept-Language, Cache-Control, Connection, Cookie等字段。Accept用于指定客户端用于接受哪些类型的信息，Accept-Encoding与Accept类似，它用于指定接受的编码方式。*Connection设置为Keep-alive用于告诉客户端本次HTTP请求结束之后并不需要关闭TCP连接，这样可以使下次HTTP请求使用相同的TCP通道，节省TCP连接建立的时间*。

#### 请求正文

当使用POST, PUT等方法时，通常需要==客户端向服务器传递数据==。这些**数据就储存在请求正文中**。在请求包头中有一些与请求正文相关的信息，例如: 现在的Web应用通常采用Rest架构，请求的数据格式一般为json。这时就需要设置Content-Type: application/json。

### 服务器处理请求并返回HTTP报文

自然而然这部分对应的就是后端工程师眼中的HTTP。后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般是由Web服务器去进行，我使用过的Web服务器有Tomcat, Jetty和Netty等等。

HTTP响应报文也是由三部分组成: **状态码**, **响应报头**和**响应报文**。

#### 状态码

状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:

- 1xx：指示信息–表示请求已接收，继续处理。
- 2xx：成功–表示请求已被成功接收、理解、接受。
- 3xx：重定向–要完成请求必须进行更进一步的操作。
- 4xx：客户端错误–请求有语法错误或请求无法实现。
- 5xx：服务器端错误–服务器未能实现合法的请求。
  平时遇到比较常见的状态码有:200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500(分别表示什么请自行查找)。

TODO:

- 301和302有什么区别？
- HTTP缓存

#### 响应报头

常见的响应报头字段有: Server, Connection...。

#### 响应报文

==服务器返回给浏览器的文本信息==，通常HTML, CSS, JS, 图片等文件就放在这一部分。

### 浏览器解析渲染页面

浏览器在收到HTML,CSS,JS文件后，它是如何把页面呈现到屏幕上的？下图对应的就是WebKit渲染的过程。![WebKitæ¸²æè¿ç¨](https://segmentfault.com/img/bVCZ1H?w=694&h=340)

​	浏览器是一个**边解析边渲染**的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。

![img](https://segmentfault.com/img/bVC1uE?w=734&h=689)

​	JS的解析是由浏览器中的JS解析引擎完成的。**JS是单线程运行**，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。==但是又存在某些任务比较耗时，如IO读写等==，所以需要一种机制可以先执行排在后面的任务，这就是：**同步任务(synchronous)和异步任务(asynchronous)**。JS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做**事件循环(Event loop)**。

浏览器在解析过程中，如果遇到请求外部资源时，如图像,iconfont,JS等。浏览器将重复1-6过程下载该资源。请求过程是异步的，并不会影响HTML文档进行加载，但是当文档加载过程中遇到JS文件，HTML文档会挂起渲染过程，不仅要等到文档中JS文件加载完毕还要等待解析执行完毕，才会继续HTML的渲染过程。原因是因为==JS有可能修改DOM结构==，这就意味着JS执行完成前，后续所有资源的下载是没有必要的，这就是JS阻塞后续资源下载的根本原因。==CSS文件的加载不影响JS文件的加载，但是却影响JS文件的执行==。==JS代码执行前浏览器必须保证CSS文件已经下载并加载完毕==。

## Web优化

上面部分主要介绍了一次完整的请求对应的过程，了解该过程的目的无非就是为了Web优化。在谈到Web优化之前，我们回到一个更原始的问题，Web前端的本质是什么。我的理解是: ==将信息快速并友好的展示给用户并能够与用户进行交互==。快速的意思就是在尽可能短的时间内完成页面的加载，试想一下当你在淘宝购买东西的时候，淘宝页面加载了10几秒才显示出物品，这个时候你还有心情去购买吗？怎么快速的完成页面的加载呢？优雅的学院派雅虎给出了常用的一些手段，也就是我们熟悉的[雅虎34条军规](https://developer.yahoo.com/performance/)。这34军规实际上就是围绕请求过程进行的一些优化方式。

如何尽快的加载资源？答案就是**能不从网络中加载的资源就不从网络中加载**，当我们合理使用缓存，将资源放在浏览器端，这是最快的方式。如果资源必须从网络中加载，则要考虑缩短连接时间，即DNS优化部分;减少响应内容大小，即对内容进行压缩。另一方面，如果加载的资源数比较少的话，也可以快速的响应用户。当资源到达浏览器之后，浏览器开始进行解析渲染，浏览器中最耗时的部分就是reflow，所以围绕这一部分就是考虑如何减少reflow的次数。